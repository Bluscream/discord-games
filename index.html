<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Discord Games Browser</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
  <style>
    .loading-spinner {
      display: none;
    }

    .table-container {
      height: calc(100vh - 200px);
      overflow-y: auto;
    }

    /* Make the results card take full height */
    .results-card {
      height: calc(100vh - 120px);
      display: flex;
      flex-direction: column;
    }

    .table-responsive {
      flex: 1;
      overflow-y: auto;
    }

    .executable-badge {
      font-size: 0.8em;
    }

    .theme-badge {
      font-size: 0.75em;
    }
  </style>
</head>

<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
    <div class="container-fluid">
      <span class="navbar-brand mb-0 h1">üéÆ Discord Games Browser</span>

      <div class="navbar-nav ms-auto d-flex align-items-center">
        <!-- Search Box -->
        <div class="nav-item me-3">
          <input type="text" class="form-control form-control-sm" id="searchInput" placeholder="Search games..." style="width: 200px;">
        </div>

        <!-- Filter Dropdown -->
        <div class="nav-item dropdown me-3">
          <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" id="filterDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="bi bi-funnel"></i> Filter
          </button>
          <ul class="dropdown-menu dropdown-menu-end" id="filterMenu">
            <li>
              <h6 class="dropdown-header">Theme</h6>
            </li>
            <li><a class="dropdown-item" href="#" data-filter="theme" data-value="">All Themes</a></li>
            <li>
              <hr class="dropdown-divider">
            </li>
            <li>
              <h6 class="dropdown-header">Operating System</h6>
            </li>
            <li><a class="dropdown-item" href="#" data-filter="os" data-value="">All OS</a></li>
            <li><a class="dropdown-item" href="#" data-filter="os" data-value="win32">Windows</a></li>
            <li><a class="dropdown-item" href="#" data-filter="os" data-value="darwin">macOS</a></li>
            <li><a class="dropdown-item" href="#" data-filter="os" data-value="linux">Linux</a></li>
          </ul>
        </div>

        <!-- Sort Dropdown -->
        <div class="nav-item dropdown me-3">
          <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" id="sortSelect" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="bi bi-sort-alpha-down"></i> Sort
          </button>
          <ul class="dropdown-menu dropdown-menu-end">
            <li><a class="dropdown-item" href="#" data-sort="name">Name (A-Z)</a></li>
            <li><a class="dropdown-item" href="#" data-sort="name-desc">Name (Z-A)</a></li>
            <li><a class="dropdown-item" href="#" data-sort="id">ID (A-Z)</a></li>
            <li><a class="dropdown-item" href="#" data-sort="id-desc">ID (Z-A)</a></li>
            <li><a class="dropdown-item" href="#" data-sort="executables">Executables Count</a></li>
            <li><a class="dropdown-item" href="#" data-sort="themes">Themes Count</a></li>
            <li><a class="dropdown-item" href="#" data-sort="hook">Hook Support</a></li>
            <li><a class="dropdown-item" href="#" data-sort="overlay">Overlay Support</a></li>
          </ul>
        </div>

        <!-- Proxy Dropdown -->
        <div class="nav-item dropdown me-3">
          <button class="btn btn-outline-light dropdown-toggle" type="button" id="proxyDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="bi bi-globe"></i> Proxy
          </button>
          <ul class="dropdown-menu dropdown-menu-end" id="proxyMenu">
            <li><a class="dropdown-item" href="#" data-proxy="direct">üåê Direct (No Proxy)</a></li>
            <li>
              <hr class="dropdown-divider">
            </li>
            <!-- Proxy items will be populated dynamically -->
            <li>
              <hr class="dropdown-divider">
            </li>
            <li><a class="dropdown-item" href="#" data-proxy="custom">Custom Proxy...</a></li>
          </ul>
        </div>

        <!-- Action Buttons -->
        <button class="btn btn-primary me-2" id="loadGames">
          <i class="bi bi-download"></i> Load
        </button>
        <button class="btn btn-outline-secondary" id="clearData">
          <i class="bi bi-trash"></i> Clear
        </button>
      </div>
    </div>
  </nav>

  <div class="container-fluid">
    <div class="row">
      <div class="col-12">

        <!-- Loading Indicator -->
        <div class="text-center loading-spinner" id="loadingSpinner">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2">Loading games data...</p>
        </div>


        <!-- Results Table -->
        <div class="card results-card" id="resultsCard" style="display: none;">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Games (<span id="gameCount">0</span>)</h5>
            <small class="text-muted">All platforms supported</small>
          </div>
          <div class="card-body p-0">
            <div class="table-responsive">
              <table class="table table-hover mb-0" id="gamesTable">
                <thead class="table-dark sticky-top">
                  <tr>
                    <th>Icon</th>
                    <th>Name</th>
                    <th>Aliases</th>
                    <th>ID</th>
                    <th>Executables</th>
                    <th>Themes</th>
                    <th>Hook</th>
                    <th>Overlay</th>
                    <th>Overlay Hook</th>
                    <th>Overlay Methods</th>
                    <th>Overlay Warn</th>
                    <th>Icon Hash</th>
                  </tr>
                </thead>
                <tbody id="gamesTableBody">
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Error Alert -->
        <div class="alert alert-danger" id="errorAlert" style="display: none;">
          <i class="bi bi-exclamation-triangle"></i>
          <span id="errorMessage"></span>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    let gamesData = [];
    let filteredData = [];

    // Discord API configuration
    const discordApiUrl = 'https://discord.com/api/v9/applications/detectable';

    // CORS Proxy configuration
    const proxyList = [
      { name: 'corsproxy.io', url: 'https://corsproxy.io/?{url}' },
      { name: 'api.allorigins.win', url: 'https://api.allorigins.win/raw?url={url}' },
      { name: 'api.codetabs.com', url: 'https://api.codetabs.com/v1/proxy?quest={url}' },
      { name: 'thingproxy.freeboard.io', url: 'https://thingproxy.freeboard.io/fetch/{url}' },
      { name: 'cors-anywhere.herokuapp.com', url: 'https://cors-anywhere.herokuapp.com/{url}' }
    ];

    let selectedProxy = proxyList[0].url; // Default to first proxy (corsproxy.io)
    const proxyDropdown = document.getElementById('proxyDropdown');
    const proxyMenu = document.getElementById('proxyMenu');
    const loadGamesBtn = document.getElementById('loadGames');
    const clearDataBtn = document.getElementById('clearData');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const resultsCard = document.getElementById('resultsCard');
    const errorAlert = document.getElementById('errorAlert');
    const errorMessage = document.getElementById('errorMessage');

    // Filter elements
    const searchInput = document.getElementById('searchInput');
    const filterDropdown = document.getElementById('filterDropdown');
    const filterMenu = document.getElementById('filterMenu');
    const sortSelect = document.getElementById('sortSelect');
    const gameCount = document.getElementById('gameCount');
    const gamesTableBody = document.getElementById('gamesTableBody');

    // Current filter/sort state
    let currentTheme = '';
    let currentOS = '';
    let currentSort = 'name';

    // Populate proxy menu
    function populateProxyMenu() {
      const directItem = proxyMenu.querySelector('[data-proxy="direct"]');
      const customItem = proxyMenu.querySelector('[data-proxy="custom"]');

      // Clear existing proxy items (keep direct and custom)
      const existingItems = proxyMenu.querySelectorAll('[data-proxy]:not([data-proxy="direct"]):not([data-proxy="custom"])');
      existingItems.forEach(item => item.remove());

      // Add proxy items from the list
      const divider = directItem.nextElementSibling;
      proxyList.forEach(proxy => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.className = 'dropdown-item';
        a.href = '#';
        a.setAttribute('data-proxy', proxy.url);
        a.textContent = proxy.name;
        li.appendChild(a);
        proxyMenu.insertBefore(li, customItem.parentElement);
      });

      // Set default proxy button text
      proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> ' + proxyList[0].name;
    }

    // Handle proxy dropdown selection
    document.querySelectorAll('[data-proxy]').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        const proxy = this.getAttribute('data-proxy');
        console.log('üîÑ Proxy selection changed to:', proxy);

        if (proxy === 'custom') {
          const customUrl = prompt('Enter custom proxy URL ({url} will be replaced)\n\nExample: https://myproxy.com/fetch?url={url}');
          if (customUrl) {
            selectedProxy = customUrl;
            proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> Custom Proxy';
            updateUrl();
          }
        } else if (proxy === 'direct') {
          selectedProxy = 'direct';
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> Direct (No Proxy)';
          updateUrl();
        } else {
          selectedProxy = proxy;
          // Find the proxy name from the list
          const proxyName = proxyList.find(p => p.url === proxy)?.name || this.textContent;
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> ' + proxyName;
          updateUrl();
        }
      });
    });

    // Handle filter dropdown
    document.querySelectorAll('[data-filter]').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        const filterType = this.getAttribute('data-filter');
        const filterValue = this.getAttribute('data-value');

        if (filterType === 'theme') {
          currentTheme = filterValue;
        } else if (filterType === 'os') {
          currentOS = filterValue;
        }

        updateFilterButton();
        applyFilters();
      });
    });

    // Handle sort dropdown
    document.querySelectorAll('[data-sort]').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        currentSort = this.getAttribute('data-sort');
        sortSelect.innerHTML = '<i class="bi bi-sort-alpha-down"></i> ' + this.textContent;
        applyFilters();
      });
    });

    // Update filter button text
    function updateFilterButton() {
      let buttonText = 'Filter';
      const filters = [];

      if (currentTheme) {
        filters.push(`Theme: ${currentTheme}`);
      }
      if (currentOS) {
        const osNames = { 'win32': 'Windows', 'darwin': 'macOS', 'linux': 'Linux' };
        filters.push(`OS: ${osNames[currentOS] || currentOS}`);
      }

      if (filters.length > 0) {
        buttonText = filters.join(', ');
      }

      filterDropdown.innerHTML = '<i class="bi bi-funnel"></i> ' + buttonText;
    }

    // Update URL with current proxy
    function updateUrl() {
      const url = new URL(window.location);
      url.searchParams.set('proxy', selectedProxy);
      window.history.replaceState({}, '', url);
    }

    // Load proxy from URL parameters
    function loadProxyFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const proxyParam = urlParams.get('proxy');
      const loadParam = urlParams.get('load');

      if (proxyParam) {
        selectedProxy = proxyParam;

        if (proxyParam === 'direct') {
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> Direct (No Proxy)';
        } else {
          // Find the proxy name from the list
          const proxyName = proxyList.find(p => p.url === proxyParam)?.name || 'Custom Proxy';
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> ' + proxyName;
        }

        if (loadParam === 'true' || loadParam === '1') {
          // Auto-load with the specified proxy
          loadGames();
        }
      }
    }



    // Load games function
    async function loadGames() {
      console.log('üéÆ Starting loadGames function');
      console.log('üì° Selected proxy:', selectedProxy);
      console.log('üåê Discord API URL:', discordApiUrl);

      let proxyUrl = selectedProxy;

      // Show loading state
      console.log('‚è≥ Showing loading state');
      loadingSpinner.style.display = 'block';
      resultsCard.style.display = 'none';
      errorAlert.style.display = 'none';
      loadGamesBtn.disabled = true;

      // Update loading text to show we're fetching
      const loadingText = loadingSpinner.querySelector('.loading-text');
      if (loadingText) {
        loadingText.textContent = 'Fetching games from Discord API...';
      }

      try {
        let fetchUrl;

        if (proxyUrl === 'direct') {
          // Direct request without proxy
          fetchUrl = discordApiUrl;
          console.log('üåê Using direct connection to:', fetchUrl);
        } else if (proxyUrl.includes('{url}')) {
          // Proxy format: replace {url} with encoded Discord API URL
          fetchUrl = proxyUrl.replace('{url}', encodeURIComponent(discordApiUrl));
          console.log('üîÑ Using proxy:', proxyUrl);
          console.log('üîó Final URL:', fetchUrl);
        } else {
          // Fallback for old format (should not happen with new system)
          fetchUrl = proxyUrl + discordApiUrl;
          console.log('‚ö†Ô∏è Using fallback URL construction:', fetchUrl);
        }

        console.log('üì° Making fetch request to:', fetchUrl);
        const response = await fetch(fetchUrl);
        console.log('üìä Response status:', response.status, response.statusText);
        console.log('üìã Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          console.error('‚ùå Response not OK:', response.status, response.statusText);
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        // Parse JSON response
        console.log('üì¶ Parsing JSON response');
        gamesData = await response.json();
        console.log('üìä Parsed games data:', gamesData.length, 'games');

        // Update loading text with game count right after parsing
        const loadingText = loadingSpinner.querySelector('.loading-text');
        if (loadingText) {
          loadingText.textContent = `Processing ${gamesData.length} games...`;
        }

        // Use setTimeout to break up the work and keep UI responsive
        setTimeout(() => {
          console.log('üîÑ Starting async processing');
          filteredData = [...gamesData];
          populateFilters();

          // Render table in chunks to prevent UI blocking
          renderTableAsync();
        }, 0);

        resultsCard.style.display = 'block';

      } catch (error) {
        console.error('‚ùå Error loading games:', error);
        console.error('‚ùå Error stack:', error.stack);
        showError(`Failed to load games: ${error.message}`);
      } finally {
        console.log('üèÅ Load games function completed');
        loadingSpinner.style.display = 'none';
        loadGamesBtn.disabled = false;
      }
    }

    // Show error function
    function showError(message) {
      errorMessage.textContent = message;
      errorAlert.style.display = 'block';
    }

    // Populate filter options
    function populateFilters() {
      const themes = new Set();
      gamesData.forEach(game => {
        if (game.themes) {
          game.themes.forEach(theme => themes.add(theme));
        }
      });

      // Update theme filter menu
      const themeSection = filterMenu.querySelector('li:first-child').nextElementSibling;
      themeSection.innerHTML = '<a class="dropdown-item" href="#" data-filter="theme" data-value="">All Themes</a>';

      Array.from(themes).sort().forEach(theme => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.className = 'dropdown-item';
        a.href = '#';
        a.setAttribute('data-filter', 'theme');
        a.setAttribute('data-value', theme);
        a.textContent = theme;
        li.appendChild(a);
        themeSection.appendChild(li);
      });

      // Re-attach event listeners for new items
      document.querySelectorAll('[data-filter]').forEach(item => {
        item.addEventListener('click', function (e) {
          e.preventDefault();
          const filterType = this.getAttribute('data-filter');
          const filterValue = this.getAttribute('data-value');

          if (filterType === 'theme') {
            currentTheme = filterValue;
          } else if (filterType === 'os') {
            currentOS = filterValue;
          }

          updateFilterButton();
          applyFilters();
        });
      });
    }

    // Render table
    function renderTable() {
      // Clear existing rows
      while (gamesTableBody.firstChild) {
        gamesTableBody.removeChild(gamesTableBody.firstChild);
      }

      filteredData.forEach(game => {
        const row = document.createElement('tr');

        // Get all executables
        const allExecutables = game.executables || [];

        // Icon column
        const iconCell = document.createElement('td');
        iconCell.className = 'text-center';
        if (game.icon_hash) {
          const iconImg = document.createElement('img');
          iconImg.src = `https://cdn.discordapp.com/app-icons/${game.id}/${game.icon_hash}.png`;
          // iconImg.alt = `${game.name} icon`;
          iconImg.className = 'rounded';
          iconImg.style.width = '32px';
          iconImg.style.height = '32px';
          iconImg.style.objectFit = 'cover';
          iconImg.onerror = function () {
            // Fallback if icon fails to load
            this.style.display = 'none';
            const fallback = document.createElement('span');
            fallback.className = 'text-muted';
            fallback.textContent = 'üì±';
            fallback.style.fontSize = '24px';
            iconCell.appendChild(fallback);
          };
          iconCell.appendChild(iconImg);
        } else {
          const fallback = document.createElement('span');
          fallback.className = 'text-muted';
          fallback.textContent = 'üì±';
          fallback.style.fontSize = '24px';
          iconCell.appendChild(fallback);
        }

        // Name column
        const nameCell = document.createElement('td');
        const nameStrong = document.createElement('strong');
        nameStrong.textContent = game.name;
        nameCell.appendChild(nameStrong);

        // Aliases column
        const aliasesCell = document.createElement('td');
        if (game.aliases && game.aliases.length > 0) {
          aliasesCell.textContent = game.aliases.join(', ');
        } else {
          aliasesCell.textContent = '-';
          aliasesCell.className = 'text-muted';
        }

        // ID column
        const idCell = document.createElement('td');
        idCell.textContent = game.id;
        idCell.className = 'font-monospace small';

        // Executables column
        const executablesCell = document.createElement('td');
        if (allExecutables.length > 0) {
          allExecutables.forEach(exec => {
            const badge = document.createElement('span');
            badge.className = 'badge executable-badge me-1';

            // Set badge color based on OS
            const osColors = {
              'win32': 'bg-primary',
              'darwin': 'bg-success',
              'linux': 'bg-info'
            };
            badge.className += ' ' + (osColors[exec.os] || 'bg-secondary');

            // Add OS indicator
            const osNames = { 'win32': 'W', 'darwin': 'M', 'linux': 'L' };
            badge.textContent = `${exec.name} (${osNames[exec.os] || exec.os})`;

            if (exec.is_launcher) {
              badge.className += ' border border-warning';
              badge.title = 'Launcher';
            }
            executablesCell.appendChild(badge);
          });
        } else {
          executablesCell.textContent = '-';
          executablesCell.className = 'text-muted';
        }

        // Themes column
        const themesCell = document.createElement('td');
        if (game.themes && game.themes.length > 0) {
          game.themes.forEach(theme => {
            const badge = document.createElement('span');
            badge.className = 'badge bg-secondary theme-badge me-1';
            badge.textContent = theme;
            themesCell.appendChild(badge);
          });
        } else {
          themesCell.textContent = '-';
          themesCell.className = 'text-muted';
        }

        // Hook column
        const hookCell = document.createElement('td');
        hookCell.textContent = game.hook ? '‚úÖ' : '‚ùå';
        hookCell.className = 'text-center';

        // Overlay column
        const overlayCell = document.createElement('td');
        overlayCell.textContent = game.overlay ? '‚úÖ' : '‚ùå';
        overlayCell.className = 'text-center';

        // Overlay Hook column
        const overlayHookCell = document.createElement('td');
        overlayHookCell.textContent = game.overlay_compatibility_hook ? '‚úÖ' : '‚ùå';
        overlayHookCell.className = 'text-center';

        // Overlay Methods column
        const overlayMethodsCell = document.createElement('td');
        if (game.overlay_methods && game.overlay_methods.length > 0) {
          game.overlay_methods.forEach(method => {
            const badge = document.createElement('span');
            badge.className = 'badge bg-info me-1';
            badge.textContent = method;
            overlayMethodsCell.appendChild(badge);
          });
        } else {
          overlayMethodsCell.textContent = '-';
          overlayMethodsCell.className = 'text-muted';
        }

        // Overlay Warn column
        const overlayWarnCell = document.createElement('td');
        overlayWarnCell.textContent = game.overlay_warn ? '‚úÖ' : '‚ùå';
        overlayWarnCell.className = 'text-center';

        // Icon Hash column
        const iconHashCell = document.createElement('td');
        if (game.icon_hash) {
          iconHashCell.textContent = game.icon_hash;
          iconHashCell.className = 'font-monospace small';
        } else {
          iconHashCell.textContent = '-';
          iconHashCell.className = 'text-muted';
        }

        // Append all cells to row
        row.appendChild(iconCell);
        row.appendChild(nameCell);
        row.appendChild(aliasesCell);
        row.appendChild(idCell);
        row.appendChild(executablesCell);
        row.appendChild(themesCell);
        row.appendChild(hookCell);
        row.appendChild(overlayCell);
        row.appendChild(overlayHookCell);
        row.appendChild(overlayMethodsCell);
        row.appendChild(overlayWarnCell);
        row.appendChild(iconHashCell);

        gamesTableBody.appendChild(row);
      });

      gameCount.textContent = filteredData.length;
    }

    // Render table asynchronously in chunks to prevent UI blocking
    function renderTableAsync() {
      console.log('üé® Starting async table rendering with', filteredData.length, 'games');
      gamesTableBody.innerHTML = '';

      const chunkSize = 50; // Process 50 games at a time
      let currentIndex = 0;

      function processChunk() {
        const endIndex = Math.min(currentIndex + chunkSize, filteredData.length);
        console.log(`üìä Processing games ${currentIndex + 1}-${endIndex} of ${filteredData.length}`);

        // Update loading text with progress
        const loadingText = loadingSpinner.querySelector('.loading-text');
        if (loadingText) {
          loadingText.textContent = `Processing ${currentIndex + 1}-${endIndex} of ${filteredData.length} games...`;
        }

        for (let i = currentIndex; i < endIndex; i++) {
          const game = filteredData[i];
          const row = document.createElement('tr');

          // Get all executables
          const allExecutables = game.executables || [];

          // Icon column
          const iconCell = document.createElement('td');
          iconCell.className = 'text-center';
          if (game.icon_hash) {
            const iconImg = document.createElement('img');
            iconImg.src = `https://cdn.discordapp.com/app-icons/${game.id}/${game.icon_hash}.png`;
            iconImg.alt = `${game.name} icon`;
            iconImg.className = 'rounded';
            iconImg.style.width = '32px';
            iconImg.style.height = '32px';
            iconImg.style.objectFit = 'cover';
            iconImg.onerror = function () {
              this.style.display = 'none';
              const fallback = document.createElement('span');
              fallback.className = 'text-muted';
              fallback.textContent = 'üì±';
              fallback.style.fontSize = '24px';
              iconCell.appendChild(fallback);
            };
            iconCell.appendChild(iconImg);
          } else {
            const fallback = document.createElement('span');
            fallback.className = 'text-muted';
            fallback.textContent = 'üì±';
            fallback.style.fontSize = '24px';
            iconCell.appendChild(fallback);
          }

          // Name column
          const nameCell = document.createElement('td');
          const nameStrong = document.createElement('strong');
          nameStrong.textContent = game.name;
          nameCell.appendChild(nameStrong);

          // Aliases column
          const aliasesCell = document.createElement('td');
          if (game.aliases && game.aliases.length > 0) {
            aliasesCell.textContent = game.aliases.join(', ');
          } else {
            aliasesCell.textContent = '-';
            aliasesCell.className = 'text-muted';
          }

          // ID column
          const idCell = document.createElement('td');
          idCell.textContent = game.id;
          idCell.className = 'font-monospace small';

          // Executables column
          const executablesCell = document.createElement('td');
          if (allExecutables.length > 0) {
            allExecutables.forEach(exec => {
              const badge = document.createElement('span');
              badge.className = 'badge executable-badge me-1';

              // Set badge color based on OS
              const osColors = {
                'win32': 'bg-primary',
                'darwin': 'bg-success',
                'linux': 'bg-info'
              };
              badge.className += ' ' + (osColors[exec.os] || 'bg-secondary');

              // Add OS indicator
              const osNames = { 'win32': 'W', 'darwin': 'M', 'linux': 'L' };
              badge.textContent = `${exec.name} (${osNames[exec.os] || exec.os})`;

              if (exec.is_launcher) {
                badge.className += ' border border-warning';
                badge.title = 'Launcher';
              }
              executablesCell.appendChild(badge);
            });
          } else {
            executablesCell.textContent = '-';
            executablesCell.className = 'text-muted';
          }

          // Themes column
          const themesCell = document.createElement('td');
          if (game.themes && game.themes.length > 0) {
            game.themes.forEach(theme => {
              const badge = document.createElement('span');
              badge.className = 'badge bg-secondary theme-badge me-1';
              badge.textContent = theme;
              themesCell.appendChild(badge);
            });
          } else {
            themesCell.textContent = '-';
            themesCell.className = 'text-muted';
          }

          // Hook column
          const hookCell = document.createElement('td');
          hookCell.textContent = game.hook ? '‚úÖ' : '‚ùå';
          hookCell.className = 'text-center';

          // Overlay column
          const overlayCell = document.createElement('td');
          overlayCell.textContent = game.overlay ? '‚úÖ' : '‚ùå';
          overlayCell.className = 'text-center';

          // Overlay Hook column
          const overlayHookCell = document.createElement('td');
          overlayHookCell.textContent = game.overlay_compatibility_hook ? '‚úÖ' : '‚ùå';
          overlayHookCell.className = 'text-center';

          // Overlay Methods column
          const overlayMethodsCell = document.createElement('td');
          if (game.overlay_methods && game.overlay_methods.length > 0) {
            game.overlay_methods.forEach(method => {
              const badge = document.createElement('span');
              badge.className = 'badge bg-info me-1';
              badge.textContent = method;
              overlayMethodsCell.appendChild(badge);
            });
          } else {
            overlayMethodsCell.textContent = '-';
            overlayMethodsCell.className = 'text-muted';
          }

          // Overlay Warn column
          const overlayWarnCell = document.createElement('td');
          overlayWarnCell.textContent = game.overlay_warn ? '‚úÖ' : '‚ùå';
          overlayWarnCell.className = 'text-center';

          // Icon Hash column
          const iconHashCell = document.createElement('td');
          if (game.icon_hash) {
            iconHashCell.textContent = game.icon_hash;
            iconHashCell.className = 'font-monospace small';
          } else {
            iconHashCell.textContent = '-';
            iconHashCell.className = 'text-muted';
          }

          // Append all cells to row
          row.appendChild(iconCell);
          row.appendChild(nameCell);
          row.appendChild(aliasesCell);
          row.appendChild(idCell);
          row.appendChild(executablesCell);
          row.appendChild(themesCell);
          row.appendChild(hookCell);
          row.appendChild(overlayCell);
          row.appendChild(overlayHookCell);
          row.appendChild(overlayMethodsCell);
          row.appendChild(overlayWarnCell);
          row.appendChild(iconHashCell);

          gamesTableBody.appendChild(row);
        }

        currentIndex = endIndex;

        if (currentIndex < filteredData.length) {
          // Continue processing next chunk
          setTimeout(processChunk, 0);
        } else {
          // Finished processing all games
          console.log('‚úÖ Async table rendering completed');
          document.getElementById('gameCount').textContent = filteredData.length;

          // Hide loading spinner
          loadingSpinner.style.display = 'none';
        }
      }

      // Start processing
      processChunk();
    }

    // Filter and sort functions
    function applyFilters() {
      console.log('üîç Applying filters');
      const searchTerm = searchInput.value.toLowerCase();
      console.log('üîé Search term:', searchTerm);
      console.log('üé® Current theme filter:', currentTheme);
      console.log('üíª Current OS filter:', currentOS);

      filteredData = gamesData.filter(game => {
        // Search filter
        const matchesSearch = !searchTerm ||
          game.name.toLowerCase().includes(searchTerm) ||
          game.id.toLowerCase().includes(searchTerm) ||
          (game.aliases && game.aliases.some(alias => alias.toLowerCase().includes(searchTerm))) ||
          (game.executables && game.executables.some(exec =>
            exec.os === 'win32' && exec.name.toLowerCase().includes(searchTerm)
          )) ||
          (game.themes && game.themes.some(theme => theme.toLowerCase().includes(searchTerm))) ||
          (game.overlay_methods && game.overlay_methods.some(method => method.toLowerCase().includes(searchTerm))) ||
          (game.icon_hash && game.icon_hash.toLowerCase().includes(searchTerm));

        // Theme filter
        const matchesTheme = !currentTheme ||
          (game.themes && game.themes.includes(currentTheme));

        // OS filter
        const matchesOS = !currentOS ||
          (game.executables && game.executables.some(exec => exec.os === currentOS));

        return matchesSearch && matchesTheme && matchesOS;
      });

      console.log('üìä Filtered results:', filteredData.length, 'out of', gamesData.length, 'games');

      // Apply sorting
      console.log('üîÑ Applying sort:', currentSort);
      filteredData.sort((a, b) => {
        switch (currentSort) {
          case 'name':
            return a.name.localeCompare(b.name);
          case 'name-desc':
            return b.name.localeCompare(a.name);
          case 'id':
            return a.id.localeCompare(b.id);
          case 'id-desc':
            return b.id.localeCompare(a.id);
          case 'executables':
            const aExecs = a.executables ? a.executables.length : 0;
            const bExecs = b.executables ? b.executables.length : 0;
            return bExecs - aExecs;
          case 'themes':
            const aThemes = a.themes ? a.themes.length : 0;
            const bThemes = b.themes ? b.themes.length : 0;
            return bThemes - aThemes;
          case 'hook':
            return (b.hook ? 1 : 0) - (a.hook ? 1 : 0);
          case 'overlay':
            return (b.overlay ? 1 : 0) - (a.overlay ? 1 : 0);
          default:
            return 0;
        }
      });

      console.log('üéØ Rendering filtered table with', filteredData.length, 'games');
      renderTable();
    }

    // Event listeners
    loadGamesBtn.addEventListener('click', loadGames);
    clearDataBtn.addEventListener('click', () => {
      gamesData = [];
      filteredData = [];
      resultsCard.style.display = 'none';
      errorAlert.style.display = 'none';
    });

    searchInput.addEventListener('input', applyFilters);

    // Initialize proxy menu and URL parameters
    console.log('üöÄ Initializing application');
    console.log('üìã Populating proxy menu');
    populateProxyMenu();
    console.log('üîó Loading proxy from URL parameters');
    loadProxyFromUrl();

    // Re-attach event listeners after populating menu
    document.querySelectorAll('[data-proxy]').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        const proxy = this.getAttribute('data-proxy');

        if (proxy === 'custom') {
          const customUrl = prompt('Enter custom proxy URL ({url} will be replaced)\n\nExample: https://myproxy.com/fetch?url={url}');
          if (customUrl) {
            selectedProxy = customUrl;
            proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> Custom Proxy';
            updateUrl();
          }
        } else if (proxy === 'direct') {
          selectedProxy = 'direct';
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> Direct (No Proxy)';
          updateUrl();
        } else {
          selectedProxy = proxy;
          // Find the proxy name from the list
          const proxyName = proxyList.find(p => p.url === proxy)?.name || this.textContent;
          proxyDropdown.innerHTML = '<i class="bi bi-globe"></i> ' + proxyName;
          updateUrl();
        }
      });
    });
  </script>
</body>

</html>